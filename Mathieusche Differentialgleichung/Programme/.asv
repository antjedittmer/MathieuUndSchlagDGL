%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Calculation of the Strutt Chart (Stability Map) using the Floquet Method.
%
% Differential Equation Form: phi'' + 2D*phi' + (nu_0^2 + nu_C^2*cos(psi))*phi = 0
% Implements Peters' interpretation of the characteristic exponent (normalized frequency).
% NOTE: This version plots and saves only the minimum absolute frequency mode (w_min).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clc; clear; close all;

% --- Setup and Parameters ---
loadMat = 0; % Load mat-file if results with the same D are already available
SW = 0.1;    % Step width for nu_0^2 and nu_C^2 sweep
unt0 = 0;    % Lower bound for nu_0^2 (x-axis)
untC = 0;    % Lower bound for nu_C^2 (y-axis)
ob0 = 9;     % Upper bound for nu_0^2
obC = 9;     % Upper bound for nu_C^2

% Folder setup
fDir = 'figureFolder_Peters_Final';
if ~isfolder(fDir)
    mkdir(fDir)
end
dDir = 'dataFolder_Peters_Final';
if ~isfolder(dDir)
    mkdir(dDir)
end
excelDir = 'dataFolder_Peters_Excel_Final';
if ~isfolder(excelDir)
    mkdir(excelDir);
end

Nz = 2; % Number of equations in the DGL system (2 for a 2nd-order ODE)
DVec = 0.15; % Damping coefficient D
t0 = 0.0;
Omega = 1; % Normalized excitation frequency (Omega = 1)
T = 2*pi / Omega; % Period of the excitation (T = 2*pi)

for dIdx = 1: length(DVec)
    D = DVec(dIdx);
    
    % Initial conditions (Identity matrix for the State Transition Matrix)
    Diagonal = diag(ones(Nz,1));
    
    % MATLAB mat-file Name for all data
    matName = [strrep(sprintf('STRUTTscheKarte_Peters_D%2.1e_SW%2.1e',D,SW),'.','dot'),...
        '.mat'];
    fileName = fullfile(dDir,matName);
    
    % --- Array Pre-allocation ---
    nu02_vals = unt0:SW:ob0;
    nuC2_vals = untC:SW:obC;
    lenNu02 = length(nu02_vals);
    lenNuC2 = length(nuC2_vals);
    lenNu = lenNu02 * lenNuC2;
    lenNuDiag = min(lenNu02,lenNuC2); % Number of diagonal points (nu_0^2 == nu_C^2)
    buffer.Pos = 0;
    buffer.Neg = 0; % Added this line, as it was missing in the original code, but used in the function

    % Storage: nu02, nuC2, Re_s1, Re_s2, Im_s1/Omega, Im_s2/Omega
    CharEx = zeros(lenNuDiag, 6); 
    plotwertstabil = zeros(lenNu,3);
    
    lidx = 1; % Index for stability map (Strutt Chart)
    oidx = 1; % Index for characteristic exponents (diagonal only)
    
    if exist(fileName,'file') == 2 && loadMat == 1
        load(fileName,'CharEx','plotwertstabil');
    else
        disp(['Calculating Strutt Chart (Peters-Style) for D = ', num2str(D), '...']);
        for nu_02 = nu02_vals
            omega0 = sqrt(nu_02); % Undisturbed natural frequency (target for Peters' tracking)
            for nu_C2  = nuC2_vals
                
                options = odeset('RelTol',1e-10,'AbsTol',1e-12);
                
                % Solve the DGL system for the Monodromy Matrix columns
                for k = 1 : Nz        
                        sol = ode45(@(psi,x)MathieuDGL(psi,x,D,nu_02,nu_C2), [t0,T], Diagonal(:,k), options);
                        MonoVek  = deval(sol,T);
                        Monodromie(:,k) = MonoVek;
                end
                
                % Characteristic Multipliers (Eigenvalues of the Monodromy Matrix)
                eP = eig(Monodromie);
                
                % --- Characteristic Exponents (Only Diagonal nu_0^2 = nu_C^2) ---
                if abs(nu_C2 - nu_02) < SW/2 
                    
                    % 1. Direct calculation of the Real and Raw Imaginary parts
                    Eig_Re = 1/T * log(abs(eP)); % sigma = Re(s)
                    % Eig_Im_Raw = 1/T * atan2(imag(eP), real(eP)); % raw Im(s)
                     Eig_Im_Raw = 1/T * atan(imag(eP)./ real(eP)); % raw Im(s)
[Eig_Im_Raw, buffer] = correctImagValues(Eig_Im_Raw, buffer);

                    % 2. Peters' Style: Tracking the physical frequency (Im(s) + k*Omega)
                    PhysFreq = petersPhysicalFrequency(Eig_Im_Raw, T, omega0, Omega);

                    % Sort by Real part (stability measure)
                    [~, idx_sort] = sort(Eig_Re); 
                    
                    % Store: Real part (sigma) and Imaginary part (normalized frequency)
                    CharEx(oidx,:) = [nu_02, nu_C2, Eig_Re(idx_sort)', (PhysFreq(idx_sort)/Omega)'];
                    oidx = oidx + 1;
                end
                
                % --- Stable Combinations (Strutt Chart) ---
                if  max(abs(eP)) < 1 % Stability condition: |mu| < 1
                    b = 1;
                    plotwertstabil(lidx,:) = [nu_02,nu_C2,b];
                end
                lidx = lidx + 1;
            end
        end
        % Delete pure zero rows
        plotwertstabil =  plotwertstabil(any(plotwertstabil,2),:);
        save(fileName,'CharEx','plotwertstabil');
    end
    
    % --- Optional: Excel Export ---
    try
        CharExTable = array2table(CharEx,'VariableNames',...
            {'nu02','nuC2','Re_s1','Re_s2', 'Freq_s1_norm', 'Freq_s2_norm'});
        excelfilename = strrep(fileName,'.mat','_CharExPhys.xlsx');
        excelfilename1 = strrep(excelfilename,dDir,excelDir);
        writetable(CharExTable,excelfilename1)
    catch ME
        warning(['Error during Excel export: ', ME.message]);
    end
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Graphical Representation (Peters Axes)
    cl = lines;
    fs = 10.5;
    hf = figure(dIdx);
    hf.Position = [10 10 600 700];
    
    % Data for plotting (Diagonal points)
    xachse = CharEx(:,1);
    
    h(1) = subplot(3,1,1);
    % Strutt Chart: nu_0^2 vs nu_C^2
    scatter(plotwertstabil(:,1),plotwertstabil(:,2),5,'filled');
    title({['Strutt Chart for $\ddot{\phi} + 2D \dot{\phi} + (\nu^2_0 + \nu^2_C \cos(\psi))\phi = 0$ ($D = $', num2str(D), ')']...
        '$\rm{Stability: } \max(|\mu|) < 1$'},'interpreter','latex','FontSize', fs+2);
    ylabel('Parameter $\nu_C^2$ $\rm{[-]}$','interpreter','latex','FontSize', fs+2);
    grid on;
    
    % Real parts of char. exponents: $\sigma = Re(s)$
    h(2) = subplot(3,1,2);
    plot(xachse,CharEx(:,3),'LineWidth', 1.5, 'Color', cl(1,:), 'DisplayName', '$\sigma_1$');
    hold on;
    plot(xachse,CharEx(:,4),'LineWidth', 1.5, 'Color', cl(2,:), 'DisplayName', '$\sigma_2$');
    yline(0, 'k--');
    title('Real Part (Damping) $\sigma = Re(s) = \frac{1}{T}\ln(|\mu|)$','interpreter','latex','FontSize', fs+2);
    ylabel('Damping Exponent $\sigma$ $\rm{[-]}$','interpreter','latex','FontSize', fs+2); 
    grid on;
    legend('Location','NorthEast', 'Interpreter','latex');

    % Imaginary parts: $\omega/\Omega = Im(s)/\Omega$
    h(3) = subplot(3,1,3); 
    
    % --- CALCULATION AND SAVING OF SINGLE SMOOTH CURVE ---
    % CharEx(:,5) and CharEx(:,6) hold the two physical frequencies (omega1/Omega and omega2/Omega).
    % We take the absolute value and select the smallest at each point to form one smooth curve.
    min_freq_norm = min(abs(CharEx(:,5:6)), [], 2);
    
    plot(xachse, min_freq_norm,'LineWidth', 1.5, 'Color', cl(1,:), 'DisplayName', '$\omega_{\min}/\Omega$'); 
    hold on;
    grid on
    
    % Save the single frequency curve data to a new .mat file
    SingleFreqData.nu02_x_axis = xachse;
    SingleFreqData.min_normalized_frequency = min_freq_norm;
    
    singleFreqFileName = fullfile(dDir,strrep(matName,'STRUTTscheKarte','SingleFreq'));
    save(singleFreqFileName, 'SingleFreqData');
    
    disp(['Single smooth frequency curve data saved to: ', singleFreqFileName]);
    % ---------------------------------------------------------------------
    
    % Undisturbed frequencies (as reference)
    plot(xachse, sqrt(xachse)/Omega, 'k--', 'DisplayName', '$\sqrt{\nu_0^2}/\Omega$');
    plot(xachse, (1-sqrt(xachse))/Omega, 'k-.', 'DisplayName', '$(1-\sqrt{\nu_0^2})/\Omega$');
    
    title('Normalized Primary Frequency $\omega_{\min}/\Omega$ (Single Curve Selection)','interpreter','latex','FontSize', fs+2)
    xlabel('Parameter $\nu_0^2$ $\rm{[-]}$','interpreter','latex','FontSize', fs+2);
    ylabel('Normalized Frequency $\omega/\Omega$ $\rm{[-]}$','interpreter','latex','FontSize', fs+2); 
    legend('Location','NorthEast', 'Interpreter','latex');

    linkaxes(h,'x')
    for idxH = 1: length(h)
        set(h(idxH),'TickLabelInterpreter','Latex','FontSize',fs)
    end
    
    pngname = fullfile(fDir,strrep(matName,'.mat','_Exponents'));
    print(pngname, '-dpng')
end

% =========================================================================
% --- AUXILIARY FUNCTIONS (Must be saved in the script or on the MATLAB path) ---
% =========================================================================

% 1. Peters-inspired Correction Function
function PhysFreq = petersPhysicalFrequency(Eig_Im_Raw, ~, omega0, Omega)
% petersPhysicalFrequency: Selects the integer correction term k such that 
% the frequency Im(s) + k*Omega is closest to the undisturbed natural frequency 
% omega0 (Peters' physical frequency tracking logic).
    
    % Search range for k (Harmonics/Integers)
    k_range = -5:5; 
    PhysFreq = zeros(size(Eig_Im_Raw));
    
    for i = 1:length(Eig_Im_Raw)
        nu_imag_raw = Eig_Im_Raw(i);
        
        % Test all k corrections: Test Frequencies = Im(s) + k*Omega
        test_frequencies = nu_imag_raw + k_range * Omega;
        
        % The target frequency is the undisturbed natural frequency: omega0
        target_freq = omega0;
        
        % Find the best k that brings the test frequency closest to the target frequency
        [~, k_best_idx] = min(abs(test_frequencies - target_freq));
        
        PhysFreq(i) = test_frequencies(k_best_idx);
    end
end

% 2. DGL System
function dxdpsi = MathieuDGL(psi, x, D, nu_02, nu_C2)
% DGL: phi'' + 2D*phi' + (nu_0^2 + nu_C^2*cos(psi))*phi = 0
% The DGL is converted into a first-order state-space form.
    
    phi = x(1);
    phi_dot = x(2);
    
    % Coefficient of the periodic stiffness
    K_psi = nu_02 + nu_C2 * cos(psi);
    
    % Second derivative: phi_ddot = -2D*phi_dot - K_psi * phi
    phi_ddot = -2 * D * phi_dot - K_psi * phi;
    
    dxdpsi = [phi_dot; phi_ddot];
end

function  [Eig, buffer] = correctImagValues(Eig, buffer)
% correctImagValues korrigiert die Imaginaerwerte fuer stetigen Verlauf
% Inputs
% - Eig: Struct mit Vektor Eig.Imag mit zwei Werten der Imaginaerteile
% - buffer struct: Puffer mit letzten Werten fuer Maximum und Minimum
% Outputs
% - Eig: Struct mit angehaengtem, korrigierten Imaginaerteilen
% - buffer struct: Puffer ueberschrieben mit neuen Werten fuer Maximum und Minimum
% Zwei Checks fuer das korrekte Format
if nargin~= 2
    error('Two inputs are expected: The current imaginary part of the eigenvalues and the buffer with the last values');
end
if max(size(Eig))~= 2 || min(size(Eig))~= 1
    error('The current imaginary parts of an eigenvalue pair is expected');
end
% Sortiere Imaginaerteil
EigImagSort = sort(Eig);
% Imaginaeranteil kontinuierlich steigend oder fallend
tmp = EigImagSort(2);
tmpNeg = EigImagSort(1);

% Initialize buffer.Pos/buffer.Neg if they don't exist, though they should be
% initialized in the main loop to 0
if ~isfield(buffer, 'Pos'), buffer.Pos = 0; end
if ~isfield(buffer, 'Neg'), buffer.Neg = 0; end

if buffer.Pos <= tmp || (abs(tmp) < 10^-5) % Wert uebernehmen
    Eig.ImagCorrected = tmp; % steigender pos. Wert
    Eig.ImagCorrectedNeg = tmpNeg;  % fallender neg. Wert
    buffer.Pos = 0; % Removed based on original logic, these were only placeholders
    buffer.Neg = 0;
else  % 'korrigierten' Wert nehmen fuer kontinuierlichen Verlauf
    % Wird der 'else'-Zweig getriggert, ist der buffer
    % bei 90 Grad (1.57 rad). Der positive Imaginaerteil ist damit
    % die Summe aus 180 Grad und dem negativen Winkel, dessen
    % Wert von -90 Grad zu 0 Grad laeuft.
    Eig.ImagCorrected = 2*buffer.Pos  + tmpNeg; % korrigierter pos. Wert
    Eig.ImagCorrectedNeg  = 2*buffer.Neg + tmp; % korrigierter neg. Wert
end
% Buffer ueberschreiben mit aktuellem Wert
buffer.Pos = max(tmp,buffer.Pos); % Maximum speichern
buffer.Neg = min(tmpNeg,buffer.Neg); % Minimum speichern
% Anmerkung: hier kammen leider andere Werte raus als bei atanh
% Eig.ImagAngle = 1/T * angle(imag(eP)./real(eP));
end