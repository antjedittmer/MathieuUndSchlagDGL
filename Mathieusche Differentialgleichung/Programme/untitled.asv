%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Stability Analysis (Strutt Chart) using Floquet Method.
%
% Implements Arnold-style presentation (symmetric curve) using the
% Peters' Interpretation for frequency tracking.
% Differential Equation Form: phi'' + 2D*phi' + (nu_0^2 + nu_C^2*cos(psi))*phi = 0
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clc; clear; close all;

% --- Setup and Parameters ---
loadMat = 0; % Load mat-file if results with the same D are already available
SW = 0.1;    % Step width for nu_0^2 and nu_C^2 sweep

unt0 = 0;    % Lower bound for nu_0^2 (x-axis)
untC = 0;    % Lower bound for nu_C^2 (y-axis)
ob0  = 9;    % Upper bound for nu_0^2
obC  = 9;    % Upper bound for nu_C^2

% Folder setup (Updated to reflect Arnold/Peters combined style)
fDir = 'figureFolder_Arnold_Peters';
if ~isfolder(fDir)
    mkdir(fDir)
end
dDir = 'dataFolder_Arnold_Peters';
if ~isfolder(dDir)
    mkdir(dDir)
end
excelDir = 'dataFolder_Arnold_Peters_Excel';
if ~isfolder(excelDir)
    mkdir(excelDir);
end

Nz   = 2;      % Number of equations in the DGL system (2 for a 2nd-order ODE)
DVec = 0.15;   % Damping coefficient D

t0    = 0.0;
Omega = 1;          % Normalized excitation frequency (Omega = 1)
T     = 2*pi/Omega; % Period of the excitation (T = 2*pi)

for dIdx = 1:length(DVec)
    D = DVec(dIdx);

    % Initial conditions (Identity matrix for the State Transition Matrix)
    Diagonal = diag(ones(Nz,1));

    % MATLAB mat-file Name for all data (Updated Name)
    matName = [strrep(sprintf('STRUTTscheKarte_Arnold_Peters_D%2.1e_SW%2.1e',D,SW),'.','dot'),...
        '.mat'];
    fileName = fullfile(dDir,matName);

    % --- Array Pre-allocation ---
    nu02_vals = unt0:SW:ob0;
    nuC2_vals = untC:SW:obC;
    lenNu02   = length(nu02_vals);
    lenNuC2   = length(nuC2_vals);
    lenNu     = lenNu02 * lenNuC2;
    lenNuDiag = min(lenNu02,lenNuC2); % Number of diagonal points (nu_0^2 == nu_C^2)
    buffer.Pos = 0;
    buffer.Neg = 0; % Added this line, as it was missing in the original code, but used in the function

    % Storage: nu02, nuC2, Re_s1, Re_s2, Im_s1/Omega, Im_s2/Omega
    CharEx         = zeros(lenNuDiag, 6);
    plotwertstabil = zeros(lenNu,3);

    lidx = 1; % Index for stability map (Strutt Chart)
    oidx = 1; % Index for characteristic exponents (diagonal only)

    if exist(fileName,'file') == 2 && loadMat == 1
        load(fileName,'CharEx','plotwertstabil');
    else
        disp(['Calculating Strutt Chart (Arnold/Peters Style) for D = ', num2str(D), '...']);
        for nu_02 = nu02_vals
            omega0 = sqrt(nu_02); % Undisturbed natural frequency (target for Peters' tracking)
            for nu_C2  = nuC2_vals

                options = odeset('RelTol',1e-10,'AbsTol',1e-12);

                % Solve the DGL system for the Monodromy Matrix columns
                for k = 1:Nz
                    sol = ode45(@(psi,x)MathieuDGL(psi,x,D,nu_02,nu_C2), [t0,T], Diagonal(:,k), options);
                    MonoVek         = deval(sol,T);
                    Monodromie(:,k) = MonoVek;
                end

                % Characteristic Multipliers (Eigenvalues of the Monodromy Matrix)
                eP = eig(Monodromie);

                % --- Characteristic Exponents (Only Diagonal nu_0^2 = nu_C^2) ---
                if abs(nu_C2 - nu_02) < SW/2

                    % 1. Direct calculation of the Real and Raw Imaginary parts
                       Eig.Real = 1/T * log(abs(eP));
                    Eig.Imag = 1/T * atan(imag(eP)./real(eP));
                    % Korrigiere Imaginaerteil fuer kontinuierlichen
                    % Verlauf
                    [Eig,buffer] = correctImagValues(Eig,buffer); 

                    % 2. Peters' Style: Tracking the physical frequency (Im(s) + k*Omega)
                    PhysFreq =[Eig.ImagCorrected;Eig.ImagCorrectedNeg] Eig_Im_Raw; % petersPhysicalFrequency(Eig_Im_Raw, T, omega0, Omega); % [rad/s]

                    % Sort by Real part (stability measure) 

                    
                    [~, idx_sort] = sort(Eig_Re);

                    % Store: Real part (sigma) and Imaginary part (normalized frequency)
                    CharEx(oidx,:) = [nu_02, nu_C2, Eig_Re(idx_sort)', (PhysFreq(idx_sort))'];
                    oidx = oidx + 1;
                end

                % --- Stable Combinations (Strutt Chart) ---
                if max(abs(eP)) < 1 % Stability condition: |mu| < 1
                    b = 1;
                    plotwertstabil(lidx,:) = [nu_02,nu_C2,b];
                end
                lidx = lidx + 1;
            end
        end
        % Delete pure zero rows
        plotwertstabil = plotwertstabil(any(plotwertstabil,2),:);
        save(fileName,'CharEx','plotwertstabil');
    end

    % --- Optional: Excel Export ---
    try
        CharExTable = array2table(CharEx,'VariableNames',...
            {'nu02','nuC2','Re_s1','Re_s2', 'Freq_s1_norm', 'Freq_s2_norm'});
        excelfilename  = strrep(fileName,'.mat','_CharExPhys.xlsx');
        excelfilename1 = strrep(excelfilename,dDir,excelDir);
        writetable(CharExTable,excelfilename1)
    catch ME
        warning(['Error during Excel export: ', ME.message]);
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Graphical Representation (Arnold/Peters Style)
    cl = lines;
    fs = 10.5;
    hf = figure(dIdx);
    hf.Position = [10 10 600 700];

    % Data for plotting (Diagonal points)
    xachse = CharEx(:,1);

    % -------------------- 1) Strutt Chart ---------------------------
    h(1) = subplot(3,1,1);
    scatter(plotwertstabil(:,1),plotwertstabil(:,2),5,'filled');
    title({'Strutt Chart for $\ddot{\phi} + 2D \dot{\phi} + (\nu^2_0 + \nu^2_C \cos(\psi))\phi = 0$'...
      },'interpreter','latex','FontSize', fs+2);
    ylabel('Parameter $\nu_C^2$ $\rm{[-]}$','interpreter','latex','FontSize', fs+2);
    grid on;

    % -------------------- 2) Real parts -----------------------------
    h(2) = subplot(3,1,2);
    plot(xachse,CharEx(:,3),'LineWidth', 1.5, 'Color', cl(1,:), 'DisplayName', '$\sigma_1$');
    hold on;
    plot(xachse,CharEx(:,4),'LineWidth', 1.5, 'Color', cl(2,:), 'DisplayName', '$\sigma_2$');
    yline(0, 'k--');
    title('Real Part (Damping) $\sigma = Re(s) = \frac{1}{T}\ln(|\mu|)$','interpreter','latex','FontSize', fs+2);
    ylabel('Damping Exponent $\sigma$ $\rm{[-]}$','interpreter','latex','FontSize', fs+2);
    grid on;
    legend('Location','NorthEast', 'Interpreter','latex');

    % -------------------- 3) Imaginary part (monotone) --------------
    h(3) = subplot(3,1,3);

    % CharEx: columns 3–6 hold Re_s1, Re_s2, Freq_s1_norm, Freq_s2_norm
    Re_s1 = CharEx(:,3);
    Re_s2 = CharEx(:,4);
    Im1   = CharEx(:,5);   % Peters‑tracked, normalized by Omega
    Im2   = CharEx(:,6);

    % Take the more stable root (smaller real part) as s_R
    % use_s1 = Re_s1 <= Re_s2;
    % Im_R   = Im1;
    % Im_R(~use_s1) = Im2(~use_s1);

    % --- ENFORCE STRICTLY NON‑DECREASING Im(s_R) ---
    % Values are already normalized by Omega, so adding +1 corresponds
    % to jumping up by one integer multiple of Omega, as in Peters.[file:3]
    % Im_R_mono = Im_R;
    % for k = 2:length(Im_R_mono)
    %     while Im_R_mono(k) < Im_R_mono(k-1)
    %         Im_R_mono(k) = Im_R_mono(k) + 1;
    %     end
    % end

    plot(xachse, Im_R_mono, 'LineWidth', 1.5, ...
        'Color', cl(1,:), 'DisplayName', '$\mathrm{Im}(s_R)$');
    hold on; grid on;

    title('Imaginary Part','interpreter','latex','FontSize', fs+2)
    xlabel('Parameter $\nu_0^2$ $\rm{[-]}$','interpreter','latex','FontSize', fs+2);
    ylabel('Im$(s_R)$ $\rm{[-]}$','interpreter','latex','FontSize', fs+2);
    legend('Location','NorthEast', 'Interpreter','latex');

    linkaxes(h,'x')
    for idxH = 1:length(h)
        set(h(idxH),'TickLabelInterpreter','Latex','FontSize',fs)
    end

    pngname = fullfile(fDir,strrep(matName,'.mat','_Exponents'));
    print(pngname, '-dpng')
end

% =========================================================================
% --- AUXILIARY FUNCTIONS ---
% =========================================================================

% 1. Peters-inspired Correction Function
function PhysFreq = petersPhysicalFrequency(Eig_Im_Raw, ~, omega0, Omega)
% petersPhysicalFrequency: Selects the integer correction term k such that
% the frequency Im(s) + k*Omega is closest to the undisturbed natural
% frequency omega0 (Peters' physical frequency tracking logic).[file:3]

    % Search range for k (Harmonics/Integers)
    k_range  = -5:5;
    PhysFreq = zeros(size(Eig_Im_Raw));

    for i = 1:length(Eig_Im_Raw)
        nu_imag_raw     = Eig_Im_Raw(i);
        test_frequencies = nu_imag_raw + k_range * Omega;
        target_freq      = omega0;
        [~, k_best_idx]  = min(abs(test_frequencies - target_freq));
        PhysFreq(i)      = test_frequencies(k_best_idx);
    end
end

% 2. DGL System
function dxdpsi = MathieuDGL(psi, x, D, nu_02, nu_C2)
% DGL: phi'' + 2D*phi' + (nu_0^2 + nu_C^2*cos(psi))*phi = 0
% The DGL is converted into a first-order state-space form.[file:4]

    phi     = x(1);
    phi_dot = x(2);

    % Coefficient of the periodic stiffness
    K_psi = nu_02 + nu_C2 * cos(psi);

    % Second derivative: phi_ddot = -2D*phi_dot - K_psi * phi
    phi_ddot = -2 * D * phi_dot - K_psi * phi;

    dxdpsi = [phi_dot; phi_ddot];
end
%%
% This function was part of the original code snippet (appended at the end)
% and is required by the main script for calculating characteristic exponents.
function  [Eig, buffer] = correctImagValues(Eig, buffer)
% correctImagValues korrigiert die Imaginaerwerte fuer stetigen Verlauf
% Inputs
% - Eig: Struct mit Vektor Eig.Imag mit zwei Werten der Imaginaerteile
% - buffer struct: Puffer mit letzten Werten fuer Maximum und Minimum
% Outputs
% - Eig: Struct mit angehaengtem, korrigierten Imaginaerteilen
% - buffer struct: Puffer ueberschrieben mit neuen Werten fuer Maximum und Minimum
% Zwei Checks fuer das korrekte Format
if nargin~= 2
    error('Two inputs are expected: The current imaginary part of the eigenvalues and the buffer with the last values');
end
if max(size(Eig.Imag))~= 2 || min(size(Eig.Imag))~= 1
    error('The current imaginary parts of an eigenvalue pair is expected');
end
% Sortiere Imaginaerteil
Eig.ImagSort = sort(Eig.Imag);
% Imaginaeranteil kontinuierlich steigend oder fallend
tmp = Eig.ImagSort(2);
tmpNeg = Eig.ImagSort(1);

% Initialize buffer.Pos/buffer.Neg if they don't exist, though they should be
% initialized in the main loop to 0
if ~isfield(buffer, 'Pos'), buffer.Pos = 0; end
if ~isfield(buffer, 'Neg'), buffer.Neg = 0; end

if buffer.Pos <= tmp || (abs(tmp) < 10^-5) % Wert uebernehmen
    Eig.ImagCorrected = tmp; % steigender pos. Wert
    Eig.ImagCorrectedNeg = tmpNeg;  % fallender neg. Wert
    buffer.Pos = 0; % Removed based on original logic, these were only placeholders
    buffer.Neg = 0;
else  % 'korrigierten' Wert nehmen fuer kontinuierlichen Verlauf
    % Wird der 'else'-Zweig getriggert, ist der buffer
    % bei 90 Grad (1.57 rad). Der positive Imaginaerteil ist damit
    % die Summe aus 180 Grad und dem negativen Winkel, dessen
    % Wert von -90 Grad zu 0 Grad laeuft.
    Eig.ImagCorrected = 2*buffer.Pos  + tmpNeg; % korrigierter pos. Wert
    Eig.ImagCorrectedNeg  = 2*buffer.Neg + tmp; % korrigierter neg. Wert
end
% Buffer ueberschreiben mit aktuellem Wert
buffer.Pos = max(tmp,buffer.Pos); % Maximum speichern
buffer.Neg = min(tmpNeg,buffer.Neg); % Minimum speichern
% Anmerkung: hier kammen leider andere Werte raus als bei atanh
% Eig.ImagAngle = 1/T * angle(imag(eP)./real(eP));
end
