% modal_participation_w03_final.m
% Computes normalized harmonic modal participation vs epsilon for w = 0.3.
% Plots results using solid lines for each harmonic component.
clear; clc; close all;

% --- Parameters ---
w_sq = 0.3^2;    % Natural frequency squared (w=0.7 to match figure 7)
w = sqrt(w_sq);  % Natural frequency w = 0.7
Omega = 1;       % Fundamental angular frequency (rad per unit time)
T = 2*pi / Omega;  % Period of the parametric coefficient
N_FFT = 4096;    % Number of points for accurate FFT
N_eps = 400;     % Number of epsilon steps
eps_vals = linspace(0, 5.0, N_eps); % Range of epsilon (0 to 5.0 )
m_range = -3:3; % Harmonics to track: m=-3..+3

% Storage for results: cell array to hold [epsilon, phi_m, m] for each point
all_participation_points = cell(N_eps, 1);

% Target basis normalized freq for w = 0.7 (tracks the mode near 0.7 cycles/period)
target_norm_basis_freq = w; 

    x0 = eye(2);
for k = 1:N_eps
    epsilon = eps_vals(k);
    
    % Time-varying state matrix D(t) for x' = D(t)*x with x = [x; x_dot]
    D_func = @(t) [0, 1; -(w_sq + epsilon*sin(t)), 0];
    
    % Integrate fundamental matrix from 0 to T

    sol_ode = ode45(@(t, x) reshape(D_func(t) * reshape(x, 2, 2), 4, 1), [0, T], reshape(x0, 4, 1));
    Phi_T = reshape(deval(sol_ode, T), 2, 2);
    
    % Floquet multipliers and exponents
    [V, Lambda_mat] = eig(Phi_T);
    Lambda = diag(Lambda_mat);
    eta = log(Lambda) / T;  % eta = sigma + i*omega
    
    % Convert omega (rad/s) to cycles per period
    norm_basis_freqs = imag(eta) / (2*pi);
    
    % Map to [-0.5, 0.5) to handle wrap-around for mode selection
    norm_basis_freqs_wrapped = mod(norm_basis_freqs + 0.5, 1) - 0.5;
    
    % Find the Floquet root closest to the target frequency
    [~, mode_idx] = min(abs(abs(norm_basis_freqs_wrapped) - target_norm_basis_freq));
    eta_mode = eta(mode_idx);
    v_mode = V(:, mode_idx);
    
    % --- Compute periodic eigenvector Q(t) over one period ---
    t_fft = linspace(0, T, N_FFT + 1);
    t_fft(end) = []; 
    Phi_t_interp = deval(sol_ode, t_fft); % 4 x N_FFT
    
    Q_t = zeros(N_FFT, 1);
    for j = 1:N_FFT
        Phi_t = reshape(Phi_t_interp(:, j), 2, 2);
        % Periodic part Q(t) is derived from the full solution x(t) = exp(eta*t) * Q(t)
        A_t = Phi_t * v_mode * exp(-eta_mode * t_fft(j));
        Q_t(j) = real(A_t(1)); % Use the displacement component (first row)
    end
    
    % --- FFT and Harmonic Extraction ---
    C = fftshift(fft(Q_t) / N_FFT); 
    freq_indices = (-N_FFT/2 : N_FFT/2 - 1);
    frequencies = freq_indices / T; % cycles per unit time (m * (1/T))
    
    harmonic_magnitudes_raw = zeros(size(m_range));
    for i = 1:length(m_range)
        m = m_range(i);
        target_freq = m * (1 / T);
        [~, idx] = min(abs(frequencies - target_freq));
        harmonic_magnitudes_raw(i) = abs(C(idx));
    end
    
    % --- Normalization (Modal Participation phi_m) ---
    total_magnitude_sum = sum(harmonic_magnitudes_raw);
    if total_magnitude_sum > 1e-12
        phi_m = harmonic_magnitudes_raw / total_magnitude_sum;
    else
        phi_m = zeros(size(harmonic_magnitudes_raw));
    end
    
    % Store results
    current_eps_points = zeros(length(m_range), 3);
    current_eps_points(:, 1) = epsilon;
    current_eps_points(:, 2) = phi_m.';
    current_eps_points(:, 3) = m_range.';
    all_participation_points{k} = current_eps_points;
end

% --- Plotting Section: Use Solid Lines ---
figure('Color','w','Units','pixels','Position',[200 200 900 400]);
hold on;
title('Modal Participation, w = 0.7', 'Interpreter', 'latex');
xlabel('$\epsilon$', 'Interpreter', 'latex');
ylabel('Modal Participation', 'Interpreter', 'latex');
grid on;
set(gca, 'TickLabelInterpreter', 'latex');

all_data_matrix = vertcat(all_participation_points{:});

% Plot each harmonic as a distinct solid line
unique_m = unique(all_data_matrix(:, 3));
for m_val = unique_m'
    % Extract data for this specific harmonic (m)
    idx = (all_data_matrix(:, 3) == m_val);
    eps_for_m = all_data_matrix(idx, 1);
    phi_for_m = all_data_matrix(idx, 2);
    
    % Sort by epsilon to ensure the line connects points in order
    [eps_for_m, sort_idx] = sort(eps_for_m);
    phi_for_m = phi_for_m(sort_idx);
    
    % Use '-' for a solid line
    plot(eps_for_m, phi_for_m, '-', 'Color', 'k', 'LineWidth', 1.0);
end

axis([0 5.0 0 1.0]); % Set axis limits as in Figure 7

% Annotate labels based on Figure 7
text(0.1, 0.8, '[+0]', 'Interpreter', 'latex', 'HorizontalAlignment', 'center', 'FontSize', 10, 'Color', 'k');
text(0.1, 0.4, '[-1]', 'Interpreter', 'latex', 'HorizontalAlignment', 'center', 'FontSize', 10, 'Color', 'k');
text(1.2, 0.45, '[-1/+0]', 'Interpreter', 'latex', 'HorizontalAlignment', 'center', 'FontSize', 10, 'Color', 'k');
text(1.2, 0.15, '[-2/+1]', 'Interpreter', 'latex', 'HorizontalAlignment', 'center', 'FontSize', 10, 'Color', 'k');
text(2.5, 0.05, '[-3/+2]', 'Interpreter', 'latex', 'HorizontalAlignment', 'center', 'FontSize', 10, 'Color', 'k');
text(4.0, 0.28, '[+0]', 'Interpreter', 'latex', 'HorizontalAlignment', 'center', 'FontSize', 10, 'Color', 'k');
text(4.0, 0.2, '[-1/+1]', 'Interpreter', 'latex', 'HorizontalAlignment', 'center', 'FontSize', 10, 'Color', 'k');
text(4.0, 0.12, '[-2/+2]', 'Interpreter', 'latex', 'HorizontalAlignment', 'center', 'FontSize', 10, 'Color', 'k');
text(4.0, 0.05, '[-3/+3]', 'Interpreter', 'latex', 'HorizontalAlignment', 'center', 'FontSize', 10, 'Color', 'k');

hold off;